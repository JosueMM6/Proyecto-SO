package Clases;

import java.awt.Image;
import java.awt.Toolkit;
import java.util.ArrayList;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import java.util.Random;
import java.util.Queue;
import java.util.LinkedList;
import java.util.Comparator;

/**
 *
 * @author Josué Marín Montaño
 */
public class Procesos extends javax.swing.JFrame {
    
    private static int contador = 0;
    /**
     * Creates new form Principal
     */
    public Procesos() {
        initComponents();
        this.setLocationRelativeTo(null);
        this.setResizable(false);
        txtQuantum.setVisible(false); //Se deja de mostrar el JTextField del valor del quantum del algoritmo RR
        jLabel8.setVisible(false); //Se deja de mostrar el JLabel del valor del quantum del algoritmo RR
        btoRRF.setVisible(false); //Se deja de mostrar el botón del valor del quantum del algoritmo RR
        Image iconoPropio = Toolkit.getDefaultToolkit().getImage(getClass().getResource("/Imagenes/Icono2.png"));
        this.setIconImage(iconoPropio);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        txtTamMemOri = new javax.swing.JTextField();
        txtTamMemRes = new javax.swing.JTextField();
        txtTamPro = new javax.swing.JTextField();
        txtNombre = new javax.swing.JTextField();
        txtLlegada = new javax.swing.JTextField();
        txtEjecucion = new javax.swing.JTextField();
        txtQuantum = new javax.swing.JTextField();
        btoIniciar = new javax.swing.JButton();
        btoAgregar = new javax.swing.JButton();
        btoEliminar = new javax.swing.JButton();
        btoFCFS = new javax.swing.JButton();
        btoRR = new javax.swing.JButton();
        btoRRF = new javax.swing.JButton();
        btoSJF = new javax.swing.JButton();
        btoDatosPrueba = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        tablaIniPag = new javax.swing.JTable();
        jScrollPane2 = new javax.swing.JScrollPane();
        tablaPag = new javax.swing.JTable();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtAreaHistorial = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        tablaPagCopia = new javax.swing.JTable();
        jScrollPane5 = new javax.swing.JScrollPane();
        txtAreaEstimaciones = new javax.swing.JTextArea();
        btoSalir = new javax.swing.JButton();
        jLabel9 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Administración de memoria");
        setMaximumSize(new java.awt.Dimension(1300, 750));
        setMinimumSize(new java.awt.Dimension(1300, 750));
        setSize(new java.awt.Dimension(1300, 750));
        getContentPane().setLayout(null);

        jLabel1.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel1.setText("Tamaño de memoria:                                      [MB]");
        getContentPane().add(jLabel1);
        jLabel1.setBounds(10, 40, 320, 16);

        jLabel2.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel2.setText("Memoria restante:                                     [MB]");
        getContentPane().add(jLabel2);
        jLabel2.setBounds(520, 60, 300, 16);

        jLabel3.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel3.setText("Nombre: ");
        getContentPane().add(jLabel3);
        jLabel3.setBounds(90, 200, 60, 16);

        jLabel4.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel4.setText("Tiempo de llegada:");
        getContentPane().add(jLabel4);
        jLabel4.setBounds(30, 250, 120, 16);

        jLabel5.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel5.setText("Tiempo de ejecución: ");
        getContentPane().add(jLabel5);
        jLabel5.setBounds(17, 300, 150, 16);

        jLabel6.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel6.setText("Tamaño del proceso:                                    [MB]");
        getContentPane().add(jLabel6);
        jLabel6.setBounds(18, 350, 310, 16);

        jLabel7.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel7.setText("Ejecución de procesos");
        getContentPane().add(jLabel7);
        jLabel7.setBounds(1070, 70, 150, 16);

        jLabel8.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        jLabel8.setText("Quantum:");
        getContentPane().add(jLabel8);
        jLabel8.setBounds(990, 270, 70, 16);

        txtTamMemOri.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        txtTamMemOri.setMaximumSize(new java.awt.Dimension(140, 35));
        txtTamMemOri.setMinimumSize(new java.awt.Dimension(140, 35));
        txtTamMemOri.setPreferredSize(new java.awt.Dimension(140, 35));
        getContentPane().add(txtTamMemOri);
        txtTamMemOri.setBounds(150, 30, 140, 35);

        txtTamMemRes.setEditable(false);
        txtTamMemRes.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        txtTamMemRes.setMaximumSize(new java.awt.Dimension(136, 22));
        txtTamMemRes.setMinimumSize(new java.awt.Dimension(136, 22));
        txtTamMemRes.setPreferredSize(new java.awt.Dimension(136, 22));
        getContentPane().add(txtTamMemRes);
        txtTamMemRes.setBounds(640, 50, 140, 35);

        txtTamPro.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        txtTamPro.setMaximumSize(new java.awt.Dimension(136, 22));
        txtTamPro.setMinimumSize(new java.awt.Dimension(136, 22));
        txtTamPro.setPreferredSize(new java.awt.Dimension(136, 22));
        getContentPane().add(txtTamPro);
        txtTamPro.setBounds(150, 340, 140, 35);

        txtNombre.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        txtNombre.setMaximumSize(new java.awt.Dimension(136, 22));
        txtNombre.setMinimumSize(new java.awt.Dimension(136, 22));
        txtNombre.setPreferredSize(new java.awt.Dimension(136, 22));
        getContentPane().add(txtNombre);
        txtNombre.setBounds(150, 190, 140, 35);

        txtLlegada.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        txtLlegada.setMaximumSize(new java.awt.Dimension(136, 22));
        txtLlegada.setMinimumSize(new java.awt.Dimension(136, 22));
        txtLlegada.setPreferredSize(new java.awt.Dimension(136, 22));
        getContentPane().add(txtLlegada);
        txtLlegada.setBounds(150, 240, 140, 35);

        txtEjecucion.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        txtEjecucion.setMaximumSize(new java.awt.Dimension(136, 22));
        txtEjecucion.setMinimumSize(new java.awt.Dimension(136, 22));
        txtEjecucion.setPreferredSize(new java.awt.Dimension(136, 22));
        getContentPane().add(txtEjecucion);
        txtEjecucion.setBounds(150, 290, 140, 35);

        txtQuantum.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        getContentPane().add(txtQuantum);
        txtQuantum.setBounds(1060, 260, 85, 35);

        btoIniciar.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        btoIniciar.setText("Iniciar");
        btoIniciar.setMaximumSize(new java.awt.Dimension(136, 22));
        btoIniciar.setMinimumSize(new java.awt.Dimension(136, 22));
        btoIniciar.setPreferredSize(new java.awt.Dimension(136, 22));
        btoIniciar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btoIniciarActionPerformed(evt);
            }
        });
        getContentPane().add(btoIniciar);
        btoIniciar.setBounds(150, 80, 136, 22);

        btoAgregar.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        btoAgregar.setText("Agregar");
        btoAgregar.setMaximumSize(new java.awt.Dimension(136, 22));
        btoAgregar.setMinimumSize(new java.awt.Dimension(136, 22));
        btoAgregar.setPreferredSize(new java.awt.Dimension(136, 22));
        btoAgregar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btoAgregarActionPerformed(evt);
            }
        });
        getContentPane().add(btoAgregar);
        btoAgregar.setBounds(150, 390, 136, 22);

        btoEliminar.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        btoEliminar.setText("Eliminar proceso");
        btoEliminar.setMaximumSize(new java.awt.Dimension(136, 22));
        btoEliminar.setMinimumSize(new java.awt.Dimension(136, 22));
        btoEliminar.setPreferredSize(new java.awt.Dimension(132, 22));
        btoEliminar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btoEliminarActionPerformed(evt);
            }
        });
        getContentPane().add(btoEliminar);
        btoEliminar.setBounds(600, 350, 132, 22);

        btoFCFS.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        btoFCFS.setText("FCFS");
        btoFCFS.setMaximumSize(new java.awt.Dimension(136, 22));
        btoFCFS.setMinimumSize(new java.awt.Dimension(136, 22));
        btoFCFS.setPreferredSize(new java.awt.Dimension(136, 22));
        btoFCFS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btoFCFSActionPerformed(evt);
            }
        });
        getContentPane().add(btoFCFS);
        btoFCFS.setBounds(1070, 110, 136, 22);

        btoRR.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        btoRR.setText("RR");
        btoRR.setMaximumSize(new java.awt.Dimension(136, 22));
        btoRR.setMinimumSize(new java.awt.Dimension(136, 22));
        btoRR.setPreferredSize(new java.awt.Dimension(136, 22));
        btoRR.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btoRRActionPerformed(evt);
            }
        });
        getContentPane().add(btoRR);
        btoRR.setBounds(1070, 160, 136, 22);

        btoRRF.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        btoRRF.setText("Iniciar");
        btoRRF.setMaximumSize(new java.awt.Dimension(120, 22));
        btoRRF.setMinimumSize(new java.awt.Dimension(120, 22));
        btoRRF.setPreferredSize(new java.awt.Dimension(120, 22));
        btoRRF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btoRRFActionPerformed(evt);
            }
        });
        getContentPane().add(btoRRF);
        btoRRF.setBounds(1150, 270, 120, 22);

        btoSJF.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        btoSJF.setText("SJF");
        btoSJF.setMaximumSize(new java.awt.Dimension(136, 22));
        btoSJF.setMinimumSize(new java.awt.Dimension(136, 22));
        btoSJF.setPreferredSize(new java.awt.Dimension(136, 22));
        btoSJF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btoSJFActionPerformed(evt);
            }
        });
        getContentPane().add(btoSJF);
        btoSJF.setBounds(1070, 210, 136, 22);

        btoDatosPrueba.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        btoDatosPrueba.setText("Datos de prueba");
        btoDatosPrueba.setMaximumSize(new java.awt.Dimension(136, 22));
        btoDatosPrueba.setMinimumSize(new java.awt.Dimension(136, 22));
        btoDatosPrueba.setPreferredSize(new java.awt.Dimension(136, 22));
        btoDatosPrueba.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btoDatosPruebaActionPerformed(evt);
            }
        });
        getContentPane().add(btoDatosPrueba);
        btoDatosPrueba.setBounds(150, 110, 136, 22);

        jScrollPane1.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N

        tablaIniPag.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        tablaIniPag.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "ID", "Nombre", "Tiempo de llegada", "Tiempo de ejecución", "Tamaño [MB]", "Estado"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(tablaIniPag);
        if (tablaIniPag.getColumnModel().getColumnCount() > 0) {
            tablaIniPag.getColumnModel().getColumn(0).setMinWidth(45);
            tablaIniPag.getColumnModel().getColumn(0).setPreferredWidth(45);
            tablaIniPag.getColumnModel().getColumn(0).setMaxWidth(45);
            tablaIniPag.getColumnModel().getColumn(1).setMinWidth(75);
            tablaIniPag.getColumnModel().getColumn(1).setPreferredWidth(75);
            tablaIniPag.getColumnModel().getColumn(1).setMaxWidth(75);
            tablaIniPag.getColumnModel().getColumn(2).setMinWidth(120);
            tablaIniPag.getColumnModel().getColumn(2).setPreferredWidth(120);
            tablaIniPag.getColumnModel().getColumn(2).setMaxWidth(120);
            tablaIniPag.getColumnModel().getColumn(3).setMinWidth(125);
            tablaIniPag.getColumnModel().getColumn(3).setPreferredWidth(125);
            tablaIniPag.getColumnModel().getColumn(3).setMaxWidth(125);
        }

        getContentPane().add(jScrollPane1);
        jScrollPane1.setBounds(380, 120, 550, 220);

        tablaPag.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Dirección Fisica", "ID", "Nombre", "Tamaño Bloque [MB]"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane2.setViewportView(tablaPag);
        if (tablaPag.getColumnModel().getColumnCount() > 0) {
            tablaPag.getColumnModel().getColumn(0).setMinWidth(105);
            tablaPag.getColumnModel().getColumn(0).setPreferredWidth(105);
            tablaPag.getColumnModel().getColumn(0).setMaxWidth(105);
            tablaPag.getColumnModel().getColumn(1).setMinWidth(45);
            tablaPag.getColumnModel().getColumn(1).setPreferredWidth(45);
            tablaPag.getColumnModel().getColumn(1).setMaxWidth(45);
            tablaPag.getColumnModel().getColumn(2).setMinWidth(75);
            tablaPag.getColumnModel().getColumn(2).setPreferredWidth(75);
            tablaPag.getColumnModel().getColumn(2).setMaxWidth(75);
        }

        getContentPane().add(jScrollPane2);
        jScrollPane2.setBounds(30, 460, 350, 210);

        txtAreaHistorial.setEditable(false);
        txtAreaHistorial.setColumns(20);
        txtAreaHistorial.setFont(new java.awt.Font("Verdana", 0, 11)); // NOI18N
        txtAreaHistorial.setRows(5);
        jScrollPane4.setViewportView(txtAreaHistorial);

        getContentPane().add(jScrollPane4);
        jScrollPane4.setBounds(410, 460, 410, 210);

        jScrollPane3.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N

        tablaPagCopia.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Dirección Fisica", "ID", "Nombre", "Tamaño Bloque [MB]"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane3.setViewportView(tablaPagCopia);
        if (tablaPagCopia.getColumnModel().getColumnCount() > 0) {
            tablaPagCopia.getColumnModel().getColumn(0).setMinWidth(105);
            tablaPagCopia.getColumnModel().getColumn(0).setPreferredWidth(105);
            tablaPagCopia.getColumnModel().getColumn(0).setMaxWidth(105);
            tablaPagCopia.getColumnModel().getColumn(1).setMinWidth(45);
            tablaPagCopia.getColumnModel().getColumn(1).setPreferredWidth(45);
            tablaPagCopia.getColumnModel().getColumn(1).setMaxWidth(45);
            tablaPagCopia.getColumnModel().getColumn(2).setMinWidth(75);
            tablaPagCopia.getColumnModel().getColumn(2).setPreferredWidth(75);
            tablaPagCopia.getColumnModel().getColumn(2).setMaxWidth(75);
        }

        getContentPane().add(jScrollPane3);
        jScrollPane3.setBounds(850, 460, 430, 100);

        txtAreaEstimaciones.setEditable(false);
        txtAreaEstimaciones.setColumns(20);
        txtAreaEstimaciones.setFont(new java.awt.Font("Verdana", 0, 11)); // NOI18N
        txtAreaEstimaciones.setRows(5);
        jScrollPane5.setViewportView(txtAreaEstimaciones);

        getContentPane().add(jScrollPane5);
        jScrollPane5.setBounds(850, 570, 430, 100);

        btoSalir.setFont(new java.awt.Font("Verdana", 0, 12)); // NOI18N
        btoSalir.setText("Salir");
        btoSalir.setMaximumSize(new java.awt.Dimension(136, 22));
        btoSalir.setMinimumSize(new java.awt.Dimension(136, 22));
        btoSalir.setPreferredSize(new java.awt.Dimension(136, 22));
        btoSalir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btoSalirActionPerformed(evt);
            }
        });
        getContentPane().add(btoSalir);
        btoSalir.setBounds(620, 680, 136, 22);

        jLabel9.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Imagenes/Fondo2_1.png"))); // NOI18N
        getContentPane().add(jLabel9);
        jLabel9.setBounds(0, 0, 350, 150);

        jLabel10.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Imagenes/Fondo2_2.png"))); // NOI18N
        getContentPane().add(jLabel10);
        jLabel10.setBounds(0, 142, 350, 280);

        jLabel11.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Imagenes/Fondo2_3.png"))); // NOI18N
        getContentPane().add(jLabel11);
        jLabel11.setBounds(340, 0, 620, 420);

        jLabel12.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Imagenes/Fondo2_4.png"))); // NOI18N
        getContentPane().add(jLabel12);
        jLabel12.setBounds(950, 0, 350, 420);

        jLabel13.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Imagenes/Fondo2_5.png"))); // NOI18N
        getContentPane().add(jLabel13);
        jLabel13.setBounds(0, 410, 400, 310);

        jLabel14.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Imagenes/Fondo2_6.png"))); // NOI18N
        getContentPane().add(jLabel14);
        jLabel14.setBounds(390, 410, 440, 310);

        jLabel15.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Imagenes/Fondo2_7.png"))); // NOI18N
        getContentPane().add(jLabel15);
        jLabel15.setBounds(820, 410, 480, 310);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btoIniciarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btoIniciarActionPerformed
        try{
            int memoriaCom = Integer.parseInt(txtTamMemOri.getText()); //Sirve para pasar de texto a número entero
            if (memoriaCom < 1){ //Si el valor es negativo en el tamaño de la memoria se te manda un mensaje de error
                JOptionPane.showMessageDialog(null, "Ingrese un tamaño válido", "Error", JOptionPane.ERROR_MESSAGE);
                txtTamMemOri.setText("");
            }else{ //Si el valor es el adecuado se inicia la memoria
                int memRestante;
                memRestante = Integer.parseInt(txtTamMemOri.getText());
                txtTamMemRes.setText(String.valueOf(memRestante));
            }
            
        }catch(NumberFormatException ex){ //Si el valor es una letra en el tamaño de la memoria se te manda un mensaje de error
            JOptionPane.showMessageDialog(null, "Ingrese un tamaño válido", "Error", JOptionPane.ERROR_MESSAGE);
            txtTamMemOri.setText("");
        }
    }//GEN-LAST:event_btoIniciarActionPerformed

    private void btoAgregarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btoAgregarActionPerformed
        String estado = "Nuevo"; //Todos los procesos se incian en estado como NUEVO
        Object [] datos = {contador, txtNombre.getText(), txtLlegada.getText(), txtEjecucion.getText(), txtTamPro.getText(), estado}; //Se crea un objeto para agregar a la tabla
        DefaultTableModel modelo= (DefaultTableModel) tablaIniPag.getModel();
        tablaIniPag.setModel(modelo);
        //Los siguientres try - catch y condicionales sirven para verificar que las caracteristicas de los procesos son adecuados
        if (!txtNombre.getText().equals("")){
            try{
                int llegada = Integer.parseInt(txtLlegada.getText());
                try{
                    int ejecucion = Integer.parseInt(txtEjecucion.getText());
                    try{
                        int tamannio = Integer.parseInt(txtTamPro.getText());
                        int memoriaRestante = Integer.parseInt(txtTamMemRes.getText());
                        if (tamannio > memoriaRestante){
                            JOptionPane.showMessageDialog(null, "No hay memoria para otro proceso", "Sin memoria", JOptionPane.WARNING_MESSAGE);
                        }else{
                            if(tamannio < 1){
                                JOptionPane.showMessageDialog(null, "Ingrese un tamaño válido", "Error", JOptionPane.ERROR_MESSAGE);
                                txtTamPro.setText("");
                            }else{
                                modelo.addRow(datos); //En caso de que todo sea correcto se agrega el proceso a la tabla
                                contador++; //Aumenta el ID
                                //Reinicia los JTextField para crear nuevos valores
                                txtNombre.setText("");
                                txtLlegada.setText("");
                                txtEjecucion.setText("");
                                txtTamPro.setText("");
                                memoriaRestante = memoriaRestante - tamannio; //Se actualiza la memoria dependiendo el tamaño del proceso
                                txtTamMemRes.setText(String.valueOf(memoriaRestante)); //Se muestra el nuevo tamaño de memoria
                            }
                        }
                    }catch(NumberFormatException ex){
                        JOptionPane.showMessageDialog(null, "Ingrese un tamaño válido", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }catch(NumberFormatException ex){
                    JOptionPane.showMessageDialog(null, "Ingrese un tiempo de ejecución válido", "Error", JOptionPane.ERROR_MESSAGE);
                }
            }catch(NumberFormatException ex){
                JOptionPane.showMessageDialog(null, "Ingrese un tiempo de llegada válido", "Error", JOptionPane.ERROR_MESSAGE);
            }
        }else{
            JOptionPane.showMessageDialog(null, "Agrege un nombre al proceso", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_btoAgregarActionPerformed

    private void btoEliminarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btoEliminarActionPerformed
        //Se puede seleccionar un proceso a través del cursor y en caso de seleccionarlo se puede eliminar y actualiza la tabla
        DefaultTableModel modelo= (DefaultTableModel) tablaIniPag.getModel();
        int registro = tablaIniPag.getSelectedRow();
        if(registro < 0)
        {
            JOptionPane.showMessageDialog(null, "No se ha seleccionado ningún proceso", "Error", JOptionPane.WARNING_MESSAGE);
        }
        else{
            int memoriaRestante = Integer.parseInt(txtTamMemRes.getText());
            memoriaRestante = memoriaRestante + Integer.parseInt(""+tablaIniPag.getValueAt(registro, 4)); //Se actualiza la memoria dependiendo el tamaño del proceso
            txtTamMemRes.setText(String.valueOf(memoriaRestante)); //Se muestra el nuevo tamaño de memoria
            modelo.removeRow(registro);
        }
    }//GEN-LAST:event_btoEliminarActionPerformed

    private void btoFCFSActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btoFCFSActionPerformed
        //Tabla de la memoria en ejecucion
        int numFilas = tablaIniPag.getRowCount(); //Se cuenta el número de procesos
        int direccion = 0; //Inicia contador de direcciones fisicas 
        String direccionTabla = ""; 
        int numDir0 = 0;
        //Se generan números aleatorios y una lista con los números de los ID's para que se cargen a la memoria de forma aleatoria
        Random rand = new Random();
        ArrayList <Integer> numID = new ArrayList<Integer>();
        for (int i = 0; i < numFilas; i++) {
            numID.add(i);  
        }
        while(!numID.isEmpty()){
            int indiceAleatorio = rand.nextInt(numID.size());
            int valorSeleccionado = numID.get(indiceAleatorio);
            Object dir = tablaIniPag.getValueAt(valorSeleccionado, 4);
            String numeroDir = dir.toString();
            int numDir = Integer.parseInt(numeroDir);
            if(direccion == 0){
                direccionTabla = "0x"+String.valueOf(Integer.toHexString(numDir)).toUpperCase();
                numDir0 = numDir + 0;
                direccion++;
            }else{
                numDir0 = numDir0 + numDir;
                direccionTabla = "0x"+String.valueOf(Integer.toHexString(numDir0)).toUpperCase();
            }
            Object identificacion = tablaIniPag.getValueAt(valorSeleccionado, 0);
            Object nombreProceso = tablaIniPag.getValueAt(valorSeleccionado, 1);
            Object tamanoBloque = tablaIniPag.getValueAt(valorSeleccionado, 4);
            numID.remove(indiceAleatorio);
            Object [] datos = {direccionTabla, identificacion, nombreProceso, tamanoBloque};
            DefaultTableModel modelo= (DefaultTableModel) tablaPag.getModel();
            DefaultTableModel modelos= (DefaultTableModel) tablaPagCopia.getModel();
            tablaPag.setModel(modelo);
            tablaPagCopia.setModel(modelos);
            modelo.addRow(datos);
            modelos.addRow(datos);
        }
        
        //Memoria restante
        Object tamBloF = txtTamMemRes.getText();
        String tamBlo = tamBloF.toString();
        int tamB = Integer.parseInt(tamBlo);
        numDir0 = numDir0 + tamB;
        String dirTabla = "0x" + String.valueOf(Integer.toHexString(numDir0)).toUpperCase();
        Object [] datosRes = {dirTabla, "---", "-------", tamB};
        DefaultTableModel modelo= (DefaultTableModel) tablaPag.getModel();
        DefaultTableModel modelos= (DefaultTableModel) tablaPagCopia.getModel();
        tablaPag.setModel(modelo);
        tablaPagCopia.setModel(modelos);
        modelo.addRow(datosRes);
        modelos.addRow(datosRes);
        
        
        //Proceso de eliminación
        int numFila = tablaIniPag.getRowCount();
        int numFilasST = tablaPag.getRowCount();
        txtAreaHistorial.append("El estado de los procesos es: Listo.\n\n");
        txtAreaHistorial.append("--------- EJECUTANDO PROCESOS USANDO FCFS --------- \n");
        for (int i = 0; i < numFila; i++) {
            Object identificacionH = tablaIniPag.getValueAt(i, 0);
            Object tiempoEjecucion = tablaIniPag.getValueAt(i, 3);
            String numEjecucion = tiempoEjecucion.toString();
            String idNecesario = identificacionH.toString();
            int tEjec = Integer.parseInt(numEjecucion);
            txtAreaHistorial.append("> Proceso con ID: " + identificacionH + ", Estado: En ejecución.\n");
            for(int j = 1; j < tEjec + 1; j++){
                txtAreaHistorial.append("          Tiempo " + j + "\n");
            }
            txtAreaHistorial.append("> Proceso con ID: " + identificacionH + ", Estado: Terminado.\n\n");
            for(int x = 0; x < numFilasST; x++){
                Object idTablaPag = tablaPagCopia.getValueAt(x, 1);
                String inTabla = idTablaPag.toString();
                if(inTabla.equals(idNecesario)){
                    modelos.setValueAt(tablaPagCopia.getValueAt(x, 0), x, 0);
                    modelos.setValueAt("---", x, 1);
                    modelos.setValueAt("-------", x, 2);
                    modelos.setValueAt(tablaPagCopia.getValueAt(x, 3), x, 3);
                }
            }
        }
        
        //Ejecutando algoritmo FCFS
        ArrayList<Proceso> procesos = new ArrayList<>();
        for (int i = 0; i < tablaIniPag.getRowCount(); i++) {
            Object idOb = tablaIniPag.getValueAt(i, 0).toString();
            String id = idOb.toString();
            Object tiempoLlegadaObject = tablaIniPag.getValueAt(i, 2);
            String tiempoLlegadaOb = tiempoLlegadaObject.toString();
            int tiempoLlegada = Integer.parseInt(tiempoLlegadaOb);
            Object tiempoEjecucionObject = tablaIniPag.getValueAt(i, 3);
            String tiempoEjecucionOb = tiempoEjecucionObject.toString();
            int tiempoEjecucion = Integer.parseInt(tiempoEjecucionOb);
            procesos.add(new Proceso(id, tiempoLlegada, tiempoEjecucion));
        }
        
        procesos.sort((p1, p2) -> Integer.compare(p1.tiempoLlegada, p2.tiempoLlegada));
        
        int tiempoActual = 0;
        int tiempoEsperaTotal = 0;
        int tiempoEjecucionTotal = 0;
        
        txtAreaEstimaciones.append("-------------------- ESTADÍSTICAS -------------------- \n");
        txtAreaEstimaciones.append(String.format("%-5s %-10s %-10s %-10s %-10s \n", "ID","Llegada", "Ejecución","Finalización", "Espera"));
        for (Proceso p : procesos) {
            int tiempoEspera = tiempoActual - p.tiempoLlegada;
            tiempoEjecucionTotal += p.tiempoEjecucion;
            tiempoEsperaTotal += tiempoEspera;
            
            txtAreaEstimaciones.append(String.format("%-10s %-22s %-13s %-10s %-10s \n", p.id, p.tiempoLlegada, p.tiempoEjecucion, tiempoEspera, (tiempoActual+p.tiempoEjecucion)));
            tiempoActual += p.tiempoEjecucion;
        }
        
        double promedioEspera = (double) tiempoEsperaTotal / procesos.size();
        double promedioEjecucion = (double) tiempoEjecucionTotal / procesos.size();
        txtAreaEstimaciones.append("\nPromedio de tiempo de espera: "+promedioEspera);
        txtAreaEstimaciones.append("\nPromedio de tiempo de ejecucion: "+promedioEjecucion);         
    }//GEN-LAST:event_btoFCFSActionPerformed

    private void btoRRActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btoRRActionPerformed
        txtQuantum.setVisible(true); //Se muestra el JTextField del valor del quantum del algoritmo RR
        jLabel8.setVisible(true); //Se muestra el JLabel del valor del quantum del algoritmo RR
        btoRRF.setVisible(true); //Se muestra el botón del valor del quantum del algoritmo RR
    }//GEN-LAST:event_btoRRActionPerformed

    private void btoSJFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btoSJFActionPerformed
        //Tabla de la memoria en ejecucion
        int numFilas = tablaIniPag.getRowCount(); //Se cuenta el número de procesos 
        int direccion = 0; //Inicia contador de direcciones fisicas 
        String direccionTabla = "";
        int numDir0 = 0;
        //Se generan números aleatorios y una lista con los números de los ID's para que se cargen a la memoria de forma aleatoria
        Random rand = new Random();
        ArrayList <Integer> numID = new ArrayList<Integer>();
        for (int i = 0; i < numFilas; i++) {
            numID.add(i);  // Agregar números 0, 1, 2, ..., n
        }
        while(!numID.isEmpty()){
            int indiceAleatorio = rand.nextInt(numID.size());
            int valorSeleccionado = numID.get(indiceAleatorio);
            Object dir = tablaIniPag.getValueAt(valorSeleccionado, 4);
            String numeroDir = dir.toString();
            int numDir = Integer.parseInt(numeroDir);
            if(direccion == 0){
                direccionTabla = "0x"+String.valueOf(Integer.toHexString(numDir)).toUpperCase();
                numDir0 = numDir + 0;
                direccion++;
            }else{
                numDir0 = numDir0 + numDir;
                direccionTabla = "0x"+String.valueOf(Integer.toHexString(numDir0)).toUpperCase();
            }
            Object identificacion = tablaIniPag.getValueAt(valorSeleccionado, 0);
            Object nombreProceso = tablaIniPag.getValueAt(valorSeleccionado, 1);
            Object tamanoBloque = tablaIniPag.getValueAt(valorSeleccionado, 4);
            numID.remove(indiceAleatorio);
            Object [] datos = {direccionTabla, identificacion, nombreProceso, tamanoBloque};
            DefaultTableModel modelo= (DefaultTableModel) tablaPag.getModel();
            DefaultTableModel modelos= (DefaultTableModel) tablaPagCopia.getModel();
            tablaPag.setModel(modelo);
            tablaPagCopia.setModel(modelos);
            modelo.addRow(datos);
            modelos.addRow(datos);
        }
        
        //Memoria restante
        Object tamBloF = txtTamMemRes.getText();
        String tamBlo = tamBloF.toString();
        int tamB = Integer.parseInt(tamBlo);
        numDir0 = numDir0 + tamB;
        String dirTabla = "0x" + String.valueOf(Integer.toHexString(numDir0)).toUpperCase();
        Object [] datosRes = {dirTabla, "---", "-------", tamB};
        DefaultTableModel model= (DefaultTableModel) tablaPag.getModel();
        DefaultTableModel modelos= (DefaultTableModel) tablaPagCopia.getModel();
        tablaPag.setModel(model);
        tablaPagCopia.setModel(modelos);
        model.addRow(datosRes);
        modelos.addRow(datosRes);
        
        //Algoritmo SJF
        ArrayList<Proceso2> procesos = new ArrayList<>();
        for (int i = 0; i < tablaIniPag.getRowCount(); i++) {
            Object idOb = tablaIniPag.getValueAt(i, 0).toString();
            String idO = idOb.toString();
            int id = Integer.parseInt(idO);
            Object tiempoLlegadaObject = tablaIniPag.getValueAt(i, 2);
            String tiempoLlegadaOb = tiempoLlegadaObject.toString();
            int tiempoLlegada = Integer.parseInt(tiempoLlegadaOb);
            Object tiempoEjecucionObject = tablaIniPag.getValueAt(i, 3);
            String tiempoEjecucionOb = tiempoEjecucionObject.toString();
            int tiempoEjecucion = Integer.parseInt(tiempoEjecucionOb);
            procesos.add(new Proceso2(id, tiempoLlegada, tiempoEjecucion));
        }

        // Ordenar los procesos por tiempo de llegada
        procesos.sort(Comparator.comparingInt(p -> p.tiempoLlegada));
        
        int tiempoActual = 0;
        int procesosCompletados = 0;
        int numProcesos = procesos.size();
        
        // Variables para promedios
        int totalEspera = 0;
        int totalRetorno = 0;
        int totalRespuesta = 0;
        int totalEjecucion = 0;
        txtAreaEstimaciones.append("-------------------- ESTADÍSTICAS -------------------- \n");
        txtAreaEstimaciones.append(String.format("%-5s %-10s %-10s %-10s %-10s %-10s \n", "ID","Llegada", "Ejecución", "Finalización", "Retorno", "Espera"));
        txtAreaHistorial.append("El estado de los procesos es: Listo.\n\n");
        txtAreaHistorial.append("--------- EJECUTANDO PROCESOS USANDO SJF --------- \n");
        while (procesosCompletados < numProcesos) {
            // Filtrar procesos que ya han llegado
            ArrayList<Proceso2> disponibles = new ArrayList<>();
            for (Proceso2 p : procesos) {
                if (p.tiempoLlegada <= tiempoActual && p.tiempoFinalizacion == 0) {
                    disponibles.add(p);
                }
            }

            // Si hay procesos disponibles, seleccionar el de menor tiempo de ejecución
            if (!disponibles.isEmpty()) {
                // Ordenar por tiempo de ejecución (SJF)
                disponibles.sort(Comparator.comparingInt(p -> p.tiempoEjecucion));
                Proceso2 actual = disponibles.get(0);

                // Mostrar el proceso seleccionado para ejecución
                txtAreaHistorial.append("> Proceso con ID: " + actual.id + ", Estado: En ejecución.\n");
                
                // Simular la ejecución del proceso, mostrando el avance de tiempo
                int i = 1;
                while (actual.tiempoRestante > 0) {
                    txtAreaHistorial.append("     Tiempo " + i + "\n");
                    tiempoActual++;
                    i++;
                    actual.tiempoRestante--; // Disminuir el tiempo restante del proceso
                }

                // El proceso ha terminado
                actual.tiempoFinalizacion = tiempoActual;
                actual.tiempoRetorno = actual.tiempoFinalizacion - actual.tiempoLlegada;
                actual.tiempoEspera = actual.tiempoRetorno - actual.tiempoEjecucion;
                actual.tiempoRespuesta = actual.tiempoEspera;

                // Acumular tiempos para los promedios
                totalEspera += actual.tiempoEspera;
                totalRetorno += actual.tiempoRetorno;
                totalRespuesta += actual.tiempoRespuesta;
                totalEjecucion += actual.tiempoEjecucion;

                // Mostrar el cálculo de tiempos
                txtAreaEstimaciones.append(String.format("%-6s %-18s %-9s %-16s %-12s %-9s \n", actual.id, actual.tiempoLlegada, actual.tiempoEjecucion,actual.tiempoFinalizacion, actual.tiempoRetorno, actual.tiempoEspera));

                // Mostrar el proceso que se elimina de la lista
                txtAreaHistorial.append("> Proceso con ID: " + actual.id + ", Estado: Terminado.\n\n");
                //txtAreaHistorial.append("\n");

                procesosCompletados++;
            } else {
                // Si no hay procesos disponibles, avanzar el tiempo
                tiempoActual++;
            }
        }

        // Calcular promedios
        double promedioEspera = (double) totalEspera / numProcesos;
        double promedioRetorno = (double) totalRetorno / numProcesos;
        double promedioRespuesta = (double) totalRespuesta / numProcesos;
        double promedioEjecucion = (double) totalEjecucion / numProcesos;

        // Escribir promedios en el JTextArea
        txtAreaEstimaciones.append("\nPromedio Tiempo de Espera: " + promedioEspera);
        txtAreaEstimaciones.append("\nPromedio Tiempo de Retorno: " + promedioRetorno);
        txtAreaEstimaciones.append("\nPromedio Tiempo de Respuesta: " + promedioRespuesta);
        txtAreaEstimaciones.append("\nPromedio Tiempo de ejecución: " + promedioEjecucion);
        
        //Proceso de eliminación
        for(int x = 0; x < tablaIniPag.getRowCount(); x++){
            DefaultTableModel modelo= (DefaultTableModel) tablaPagCopia.getModel();
            modelo.setValueAt(tablaPagCopia.getValueAt(x, 0), x, 0);
            modelo.setValueAt("---", x, 1);
            modelo.setValueAt("-------", x, 2);
            modelo.setValueAt(tablaPagCopia.getValueAt(x, 3), x, 3);
        }
  
    }//GEN-LAST:event_btoSJFActionPerformed

    private void btoRRFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btoRRFActionPerformed
        try{ //Se verifica que el quantum es valido
            int quantum = Integer.parseInt(txtQuantum.getText());
            if(quantum < 1){
                JOptionPane.showMessageDialog(null, "Ingrese un tamaño de quantum válido", "Error", JOptionPane.ERROR_MESSAGE);
                txtQuantum.setText("");
            }else{
                //Tabla de la memoria en ejecucion
                int numFilas = tablaIniPag.getRowCount(); //Se cuenta el número de procesos
                int direccion = 0; //Inicia contador de direcciones fisicas 
                String direccionTabla = "";
                int numDir0 = 0;
                //Se generan números aleatorios y una lista con los números de los ID's para que se cargen a la memoria de forma aleatoria
                Random rand = new Random();
                ArrayList <Integer> numID = new ArrayList<Integer>();
                for (int i = 0; i < numFilas; i++) {
                    numID.add(i);  // Agregar números 0, 1, 2, ..., n
                }
                while(!numID.isEmpty()){
                    int indiceAleatorio = rand.nextInt(numID.size());
                    int valorSeleccionado = numID.get(indiceAleatorio);
                    Object dir = tablaIniPag.getValueAt(valorSeleccionado, 4);
                    String numeroDir = dir.toString();
                    int numDir = Integer.parseInt(numeroDir);
                    if(direccion == 0){
                        direccionTabla = "0x"+String.valueOf(Integer.toHexString(numDir)).toUpperCase();
                        numDir0 = numDir + 0;
                        direccion++;
                    }else{
                        numDir0 = numDir0 + numDir;
                        direccionTabla = "0x"+String.valueOf(Integer.toHexString(numDir0)).toUpperCase();
                    }
                    Object identificacion = tablaIniPag.getValueAt(valorSeleccionado, 0);
                    Object nombreProceso = tablaIniPag.getValueAt(valorSeleccionado, 1);
                    Object tamanoBloque = tablaIniPag.getValueAt(valorSeleccionado, 4);
                    numID.remove(indiceAleatorio);
                    Object [] datos = {direccionTabla, identificacion, nombreProceso, tamanoBloque};
                    DefaultTableModel modelo= (DefaultTableModel) tablaPag.getModel();
                    DefaultTableModel modelos= (DefaultTableModel) tablaPagCopia.getModel();
                    tablaPag.setModel(modelo);
                    tablaPagCopia.setModel(modelos);
                    modelo.addRow(datos);
                    modelos.addRow(datos);
                }
                
                //Memoria restante
                Object tamBloF = txtTamMemRes.getText();
                String tamBlo = tamBloF.toString();
                int tamB = Integer.parseInt(tamBlo);
                numDir0 = numDir0 + tamB;
                String dirTabla = "0x" + String.valueOf(Integer.toHexString(numDir0)).toUpperCase();
                Object [] datosRes = {dirTabla, "---", "-------", tamB};
                DefaultTableModel model= (DefaultTableModel) tablaPag.getModel();
                DefaultTableModel modelos= (DefaultTableModel) tablaPagCopia.getModel();
                tablaPag.setModel(model);
                tablaPagCopia.setModel(modelos);
                model.addRow(datosRes);
                modelos.addRow(datosRes);
                   
                int numRows = tablaIniPag.getRowCount();
                ArrayList<Proceso1> procesos = new ArrayList<>();
                for (int i = 0; i < numRows; i++) {
                    Object id = tablaIniPag.getValueAt(i, 0);
                    String nombre = id.toString();
                    Object tiempoLlegada = tablaIniPag.getValueAt(i, 2);
                    String tiempoLlegadaOb = tiempoLlegada.toString();
                    int llegada = Integer.parseInt(tiempoLlegadaOb);
                    Object tiempoEjecucion = tablaIniPag.getValueAt(i, 3);
                    String tiempoEjecucionOb = tiempoEjecucion.toString();
                    int burst = Integer.parseInt(tiempoEjecucionOb);
                    procesos.add(new Proceso1(nombre, llegada, burst, i));
                }
                
                
                int tiempoActual = 0;
                Queue<Proceso1> colaEspera = new LinkedList<>();

                //Listas para almacenar tiempos de cada proceso
                int[] tiemposDeEspera = new int[numRows];
                int[] tiemposDeRetorno = new int[numRows];
                int[] tiemposDeRespuesta = new int[numRows];
                int[] tiemposDeFinalizacion = new int[numRows];

                txtAreaHistorial.append("El estado de los procesos es: Listo.\n\n");
                txtAreaHistorial.append("---------- EJECUTANDO PROCESOS USANDO RR ---------- \n");
                // Ejecutar el algoritmo RR
                while (!procesos.isEmpty() || !colaEspera.isEmpty()) {
                    // Mover los procesos que han llegado al tiempo actual a la cola de espera
                    while (!procesos.isEmpty() && procesos.get(0).tiempoLlegada <= tiempoActual) {
                        colaEspera.add(procesos.remove(0));
                    }

                    if (!colaEspera.isEmpty()) {
                        Proceso1 actual = colaEspera.poll();
                        int tiempoEjecucion = Math.min(quantum, actual.tiempoEjecucion);

                        // Mostrar paso a paso en JTextArea
                        txtAreaHistorial.append("> Proceso con ID: " + actual.nombre + ", Estado: En ejecución.\n");
                        for (int q = 1; q < tiempoEjecucion + 1; q++){
                            txtAreaHistorial.append("          Tiempo " + q + "\n");
                        }
                        txtAreaHistorial.append("> Proceso con ID: " + actual.nombre + ", Estado: Bloqueado.\n");

                        // Si es la primera vez que el proceso se ejecuta, se calcula el tiempo de respuesta
                        if (actual.tiempoDeRespuesta == -1) {
                            actual.tiempoDeRespuesta = tiempoActual - actual.tiempoLlegada;
                            tiemposDeRespuesta[actual.index] = actual.tiempoDeRespuesta;
                        }

                        // Actualizar el tiempo de ejecución restante
                        actual.tiempoEjecucion -= tiempoEjecucion;

                        // Si el proceso no ha terminado, volver a la cola
                        if (actual.tiempoEjecucion > 0) {
                            colaEspera.add(actual);
                        } else {
                            // El proceso ha terminado, calcular el tiempo de finalización
                            int tiempoDeFinalizacion = tiempoActual + tiempoEjecucion;
                            tiemposDeFinalizacion[actual.index] = tiempoDeFinalizacion;

                            // Calcular el tiempo de retorno (turnaround time)
                            int tiempoDeRetorno = tiempoDeFinalizacion - actual.tiempoLlegada;
                            tiemposDeRetorno[actual.index] = tiempoDeRetorno;
                            txtAreaHistorial.append("> Proceso con ID:  " + actual.nombre + ", Estado: Terminado.\n\n");
                        }

                        // Incrementar el tiempo actual
                        tiempoActual += tiempoEjecucion;
                    } else {
                        // Si no hay procesos en la cola de espera, simplemente avanzar el tiempo
                        tiempoActual++;
                    }
                }
            
                txtAreaEstimaciones.append("-------------------- ESTADÍSTICAS -------------------- \n");
                txtAreaEstimaciones.append(String.format("%-5s %-10s %-10s %-10s %-10s %-10s \n", "ID","Llegada", "Ejecución", "Espera", "Retorno", "Respuesta"));
                double avgTiempoEspera = 0, avgTiempoRetorno = 0, avgTiempoRespuesta = 0, avgTiempoEjecucion = 0;
                for (int i = 0; i < numRows; i++) {
                    // Calcular el tiempo de espera correctamente
                    // Tiempo de espera = Tiempo de Retorno - Tiempo de Ejecución - Tiempo de Llegada
                    Object ej = tablaIniPag.getValueAt(i, 3);
                    String ej0 = ej.toString();
                    int ej1 = Integer.parseInt(ej0);
                    tiemposDeEspera[i] = tiemposDeRetorno[i] - ej1;

                    // Mostrar los resultados de cada proceso
                    Object nombre = tablaIniPag.getValueAt(i, 0);
                    Object ejecucion = tablaIniPag.getValueAt(i, 3);
                    Object llegada = tablaIniPag.getValueAt(i, 2);
                    String nom = nombre.toString();
                    String ejec = ejecucion.toString();
                    String llega = llegada.toString();
                    
                    txtAreaEstimaciones.append(String.format("%-6s %-18s %-9s %-16s %-12s %-9s \n", nom, llega, ejec,tiemposDeEspera[i], tiemposDeRetorno[i], tiemposDeRespuesta[i]));

                    // Sumar los tiempos para los promedios
                    avgTiempoEspera += tiemposDeEspera[i];
                    avgTiempoRetorno += tiemposDeRetorno[i];
                    avgTiempoRespuesta += tiemposDeRespuesta[i];
                    
                    Object tiemp = tablaIniPag.getValueAt(i, 3);
                    String tiem = tiemp.toString();
                    int tie = Integer.parseInt(tiem);
                    avgTiempoEjecucion += tie;
                }

                // Cálculo de los promedios
                avgTiempoEspera /= numRows;
                avgTiempoRetorno /= numRows;
                avgTiempoRespuesta /= numRows;
                avgTiempoEjecucion /= numRows;

                // Mostrar los tiempos promedio
                txtAreaEstimaciones.append(String.format("\nTiempo Promedio de Espera: %.2f\n", avgTiempoEspera));
                txtAreaEstimaciones.append(String.format("Tiempo Promedio de Retorno: %.2f\n", avgTiempoRetorno));
                txtAreaEstimaciones.append(String.format("Tiempo Promedio de Respuesta: %.2f\n", avgTiempoRespuesta));
                txtAreaEstimaciones.append(String.format("Tiempo Promedio de Ejecucion: %.2f\n", avgTiempoEjecucion));
                
                //Proceso de eliminación
                for(int x = 0; x < tablaIniPag.getRowCount(); x++){
                    DefaultTableModel modelo= (DefaultTableModel) tablaPagCopia.getModel();
                    modelo.setValueAt(tablaPagCopia.getValueAt(x, 0), x, 0);
                    modelo.setValueAt("---", x, 1);
                    modelo.setValueAt("-------", x, 2);
                    modelo.setValueAt(tablaPagCopia.getValueAt(x, 3), x, 3);
                }
            }
        }catch(NumberFormatException ex){
            JOptionPane.showMessageDialog(null, "Ingrese un tamaño de quantum válido", "Error", JOptionPane.ERROR_MESSAGE);
            txtQuantum.setText("");
        }
    }//GEN-LAST:event_btoRRFActionPerformed

    private void btoDatosPruebaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btoDatosPruebaActionPerformed
        //Valores de procesos de prueba
        txtQuantum.setVisible(false); //Se deja de mostrar el JTextField del valor del quantum del algoritmo RR
        jLabel8.setVisible(false); //Se deja de mostrar el JLabel del valor del quantum del algoritmo RR
        btoRRF.setVisible(false); //Se deja de mostrar el botón del valor del quantum del algoritmo RR
        txtTamMemRes.setText("325"); //Se inicia la memoria con 325
        //Se agregan los valores a la tabla
        Object[][] datos = {
                    {"0", "P0", "0", "6", "25", "Nuevo"},
                    {"1", "P1", "1", "8", "10", "Nuevo"},
                    {"2", "P2", "2", "7", "52", "Nuevo"},
                    {"3", "P3", "3", "3", "88", "Nuevo"}
                };
        
        DefaultTableModel modelo= (DefaultTableModel) tablaIniPag.getModel();
        tablaIniPag.setModel(modelo);
        
        for (Object[] row : datos) {
            modelo.addRow(row);
        }
    }//GEN-LAST:event_btoDatosPruebaActionPerformed

    private void btoSalirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btoSalirActionPerformed
        Principal principal = new Principal(); //Instancia del archivo principal
        principal.setVisible(true); //Se muestra la ventana principal
        this.dispose(); //Secierra la ventana de procesos
    }//GEN-LAST:event_btoSalirActionPerformed
    
    //Las siguientes funciones sirven para crear objetos de los procesos dependiendo que algoritmo se use se utilizara diferentes objetos
    static class Proceso{
        String id;
        int tiempoLlegada;
        int tiempoEjecucion;

        Proceso(String id, int tiempoLlegada, int tiempoEjecucion) {
            this.id = id;
            this.tiempoLlegada = tiempoLlegada;
            this.tiempoEjecucion = tiempoEjecucion;
        }
    }
    
    static class Proceso1 {
        String nombre;
        int tiempoLlegada;
        int tiempoEjecucion;
        int tiempoDeRespuesta;
        int index;  // Índice del proceso

        // Constructor renombrado a proceso1
        public Proceso1(String nombre, int tiempoLlegada, int tiempoEjecucion, int index) {
            this.nombre = nombre;
            this.tiempoLlegada = tiempoLlegada;
            this.tiempoEjecucion = tiempoEjecucion;
            this.tiempoDeRespuesta = -1;  // Inicialmente no tiene tiempo de respuesta
            this.index = index;
        }
    }
    
    static class Proceso2 {
        int id;
        int tiempoLlegada;
        int tiempoEjecucion;
        int tiempoFinalizacion;
        int tiempoRetorno;
        int tiempoEspera;
        int tiempoRespuesta;
        int tiempoRestante;
        
        public Proceso2(int id, int tiempoLlegada, int tiempoEjecucion) {
            this.id = id;
            this.tiempoLlegada = tiempoLlegada;
            this.tiempoEjecucion = tiempoEjecucion;
            this.tiempoRestante = tiempoEjecucion;
        }
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Procesos.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        
        //</editor-fold>
        
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new Procesos().setVisible(true);
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btoAgregar;
    private javax.swing.JButton btoDatosPrueba;
    private javax.swing.JButton btoEliminar;
    private javax.swing.JButton btoFCFS;
    private javax.swing.JButton btoIniciar;
    private javax.swing.JButton btoRR;
    private javax.swing.JButton btoRRF;
    private javax.swing.JButton btoSJF;
    private javax.swing.JButton btoSalir;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JTable tablaIniPag;
    private javax.swing.JTable tablaPag;
    private javax.swing.JTable tablaPagCopia;
    private javax.swing.JTextArea txtAreaEstimaciones;
    private javax.swing.JTextArea txtAreaHistorial;
    private javax.swing.JTextField txtEjecucion;
    private javax.swing.JTextField txtLlegada;
    private javax.swing.JTextField txtNombre;
    private javax.swing.JTextField txtQuantum;
    private javax.swing.JTextField txtTamMemOri;
    private javax.swing.JTextField txtTamMemRes;
    private javax.swing.JTextField txtTamPro;
    // End of variables declaration//GEN-END:variables
}